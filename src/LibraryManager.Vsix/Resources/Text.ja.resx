<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AddClientSideLibrary" xml:space="preserve">
    <value>クライアント側のライブラリを追加します</value>
    <comment>Add Client-Side Library</comment>
  </data>
  <data name="CleanLibrariesStarted" xml:space="preserve">
    <value>ライブラリのクリーニングを開始しました...</value>
    <comment>When the "Clean" command is being executed</comment>
  </data>
  <data name="CleanLibrariesSucceeded" xml:space="preserve">
    <value>ライブラリのクリーニングに成功しました</value>
    <comment>Status message</comment>
  </data>
  <data name="LibraryRestoredNoChange" xml:space="preserve">
    <value>復元が完了しました。ファイルはすでに最新です。</value>
    <comment>Status message</comment>
  </data>
  <data name="Loading" xml:space="preserve">
    <value>読み込んでいます...</value>
    <comment>Used in JSON editor for Intellisense</comment>
  </data>
  <data name="PackagesCouldNotBeLoaded" xml:space="preserve">
    <value>パッケージを読み込むことができませんでした</value>
    <comment>Used in installer dialog</comment>
  </data>
  <data name="CheckForUpdates" xml:space="preserve">
    <value>更新プログラムの確認</value>
    <comment>Used in JSON editor light bulb</comment>
  </data>
  <data name="SuggestedAction_Update_NoUpdatesFound" xml:space="preserve">
    <value>現時点で、更新プログラムはありません</value>
    <comment>Used in message box when light bulb found no updates</comment>
  </data>
  <data name="NugetInstallPrompt" xml:space="preserve">
    <value>NuGet パッケージは MSBuild プロセスを拡張するためにインストールされますが、プロジェクトにファイルは追加されません。

これにはインターネット接続が必要な場合があります。

続行しますか?</value>
  </data>
  <data name="TypeToSearch" xml:space="preserve">
    <value>&lt;検索するテキストを入力&gt;</value>
  </data>
  <data name="SelectLibraryToSelectFilesToInstall" xml:space="preserve">
    <value>&lt;ライブラリを選択して、インストールするファイルを選択してください&gt;</value>
  </data>
  <data name="DisableRestoreOnBuild" xml:space="preserve">
    <value>ビルド時にクライアント側のライブラリを無効にする(&amp;E)</value>
  </data>
  <data name="EnableRestoreOnBuild" xml:space="preserve">
    <value>ビルド時にクライアント側のライブラリの復元を有効にする(&amp;E)...</value>
  </data>
  <data name="Nuget_InstallingPackage" xml:space="preserve">
    <value>MSBuild ターゲットを含む NuGet パッケージをインストールしています...</value>
  </data>
  <data name="Nuget_PackageFailedToInstall" xml:space="preserve">
    <value>NuGet パッケージをインストールできませんでした</value>
  </data>
  <data name="Nuget_PackageFailedToUninstall" xml:space="preserve">
    <value>NuGet パッケージをアンインストールできませんでした</value>
  </data>
  <data name="Nuget_PackageInstalled" xml:space="preserve">
    <value>NuGet パッケージがインストールされました</value>
  </data>
  <data name="Nuget_PackageUninstalled" xml:space="preserve">
    <value>NuGet パッケージがアンインストールされました</value>
  </data>
  <data name="Nuget_UninstallingPackage" xml:space="preserve">
    <value>NuGet パッケージをアンインストールしています...</value>
  </data>
  <data name="UninstallLibrary" xml:space="preserve">
    <value>{0} をアンインストールします</value>
    <comment>Used in JSON editor light bulb</comment>
  </data>
  <data name="FailToDeleteLibrariesFromProject" xml:space="preserve">
    <value>プロジェクトからライブラリを削除できませんでした</value>
  </data>
  <data name="LibraryDeletedFromProject" xml:space="preserve">
    <value>{0} がプロジェクトから正常に削除されました</value>
    <comment>{0} is a file path</comment>
  </data>
  <data name="FailToAddLibrariesToProject" xml:space="preserve">
    <value>プロジェクトにライブラリを追加できませんでした</value>
  </data>
  <data name="LibraryAddedToProject" xml:space="preserve">
    <value>{0} がプロジェクトに正常に追加されました</value>
    <comment>{0} is a file path</comment>
  </data>
  <data name="OutputWindowTitle" xml:space="preserve">
    <value>ライブラリ マネージャー</value>
  </data>
  <data name="OperationInProgress" xml:space="preserve">
    <value>ライブラリ マネージャー操作が既に進行中です。</value>
  </data>
  <data name="Files" xml:space="preserve">
    <value>ファイル:</value>
  </data>
  <data name="Library" xml:space="preserve">
    <value>ライブラリ(_L):</value>
  </data>
  <data name="Provider" xml:space="preserve">
    <value>プロバイダー(_P): </value>
  </data>
  <data name="TargetLocation" xml:space="preserve">
    <value>ターゲット ロケーション(_T):</value>
  </data>
  <data name="ChooseSpecificFiles" xml:space="preserve">
    <value>特定のファイルの選択(_S):</value>
  </data>
  <data name="IncludeAllLibraryFiles" xml:space="preserve">
    <value>ライブラリのすべてのファイルを含める(_A)</value>
  </data>
  <data name="NoFilesSelected" xml:space="preserve">
    <value>ファイルが選択されていません</value>
  </data>
  <data name="Cancel" xml:space="preserve">
    <value>キャンセル(_C)</value>
  </data>
  <data name="Install" xml:space="preserve">
    <value>インストール(_I)</value>
  </data>
  <data name="Checked" xml:space="preserve">
    <value>確認済みの{0} {1}</value>
    <comment>{0} indicates PackageItemType, which could be a file or a folder. {1} is the name of the file or folder</comment>
  </data>
  <data name="UnChecked" xml:space="preserve">
    <value>未確認の{0} {1}</value>
    <comment>{0} indicates PackageItemType, which could be a file or a folder. {1} is the name of the file or folder</comment>
  </data>
  <data name="SuggestedAction_Update_Prerelease" xml:space="preserve">
    <value>プレリリース: {0}</value>
  </data>
  <data name="SuggestedAction_Update_Stable" xml:space="preserve">
    <value>安定: {0}</value>
  </data>
  <data name="SuggestedAction_Update_Title" xml:space="preserve">
    <value>ライブラリの更新</value>
    <comment>Title for SuggestedAction set</comment>
  </data>
  <data name="Indeterminate" xml:space="preserve">
    <value>不確定の{0} {1}</value>
    <comment>{0} indicates PackageItemType, which could be a file or a folder. {1} is the name of the file or folder</comment>
  </data>
  <data name="File" xml:space="preserve">
    <value>ファイル</value>
  </data>
  <data name="Folder" xml:space="preserve">
    <value>フォルダー</value>
  </data>
  <data name="CloseButtonText" xml:space="preserve">
    <value>閉じる</value>
  </data>
  <data name="NoMatchesFound" xml:space="preserve">
    <value>一致するものは見つかりませんでした</value>
  </data>
  <data name="BadLibraryId" xml:space="preserve">
    <value>ライブラリ {0} がプロバイダー {1}の名前付けスキームと一致しませんでした。{2}</value>
    <comment>Used in an error message popup.  {2} is the provider's example text (already localized elsewhere).</comment>
  </data>
</root>