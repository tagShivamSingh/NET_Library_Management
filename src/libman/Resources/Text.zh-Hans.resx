<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CacheCommandDesc" xml:space="preserve">
    <value>列出或清除 libman 缓存内容</value>
  </data>
  <data name="CleanCommandDesc" xml:space="preserve">
    <value>从项目中删除 libman.json 中定义的所有库文件</value>
  </data>
  <data name="CleanCommandRemarks" xml:space="preserve">
    <value>删除在此操作后变为空的所有文件夹。</value>
  </data>
  <data name="ConfigCommand_Description" xml:space="preserve">
    <value>获取或设置配置设置</value>
  </data>
  <data name="ConfigCommand_Examples" xml:space="preserve">
    <value>    libman config http_proxy
    libman config --set http_proxy=http://example
    libman config --setEncrypted http_proxy.password=passwordText</value>
  </data>
  <data name="ConfigCommand_ArgumentDescription" xml:space="preserve">
    <value>要检索的设置的名称</value>
  </data>
  <data name="ConfigCommand_Error_KeyNotFound" xml:space="preserve">
    <value>未找到密钥 {0}</value>
  </data>
  <data name="DefaultDestinationOptionDesc" xml:space="preserve">
    <value>相对于当前目录的路径, 如果没有为给定的库定义目标, 则应在其中安装库文件。</value>
  </data>
  <data name="DefaultProviderOptionDesc" xml:space="preserve">
    <value>未为给定库定义提供程序时要使用的提供程序。(例如 “cdnjs”、“filesystem”)</value>
  </data>
  <data name="NonInteractiveConsoleMessage" xml:space="preserve">
    <value>无法在此控制台中提示用户输入。</value>
  </data>
  <data name="DestinationOptionDesc" xml:space="preserve">
    <value>安装库的位置 (如果未指定, 将使用默认目标位置)</value>
  </data>
  <data name="ExamplesHeader" xml:space="preserve">
    <value>示例:</value>
  </data>
  <data name="FilesOptionDesc" xml:space="preserve">
    <value>要安装的指定库中的文件 (如果未指定, 则将安装库中的所有文件)</value>
  </data>
  <data name="InitCommandDesc" xml:space="preserve">
    <value>创建新的 libman. json</value>
  </data>
  <data name="InstallCommandDesc" xml:space="preserve">
    <value>向 LibMan.json 文件添加库定义, 并将库下载到指定位置</value>
  </data>
  <data name="InstallCommandExamples" xml:space="preserve">
    <value>libman install jquery@3.2.1
    libman install jquery --provider cdnjs --destination wwwroot\scripts\jquery --files jquery.min.js
    libman install myCalendar --provider filesystem --files calendar.js --files calendar.css</value>
  </data>
  <data name="InstallCommandLibraryIdArgumentDesc" xml:space="preserve">
    <value>要安装的库</value>
  </data>
  <data name="InstallCommandProviderSpecificLogic" xml:space="preserve">
    <value>CDNJS 库的库 ID 格式为“&lt;库名称&gt;@&lt;库版本&gt;”
    对于 CDNJS 库，如果库 ID 中没有指定版本，则使用最高可用版本。</value>
  </data>
  <data name="InstallCommandRemarks" xml:space="preserve">
    <value>    如果不存在 libman.json 则初始化它
    如果不存在默认提供程序，则需要 --provider 选项
    如果不存在默认目标，则需要 --destination 选项
    如果未指定文件，则包括整个库</value>
  </data>
  <data name="InvalidArgumentsMessage" xml:space="preserve">
    <value>命令的参数无效: {0}</value>
  </data>
  <data name="LibmanCommandDesc" xml:space="preserve">
    <value>库管理器</value>
  </data>
  <data name="ProviderOptionDesc" xml:space="preserve">
    <value>要使用的提供程序 (如果未指定, 将使用默认提供程序)</value>
  </data>
  <data name="ProviderSpecificLogicHeader" xml:space="preserve">
    <value>特定于提供程序的逻辑:</value>
  </data>
  <data name="RemarksHeader" xml:space="preserve">
    <value>言论:</value>
  </data>
  <data name="RestoreCommandDesc" xml:space="preserve">
    <value>从提供程序下载所有文件并将其保存到指定的目标</value>
  </data>
  <data name="RestoreCommandRemarks" xml:space="preserve">
    <value>如果当前文件夹中不存在 libman.json 则出错
    如果库指定提供程序，它将覆盖 defaultProvider
    如果库指定目标，它将覆盖 defaultDestination</value>
  </data>
  <data name="UnInstallCommandDesc" xml:space="preserve">
    <value>从指定的目标删除指定库的所有文件, 然后从 libman.json 删除指定的库定义</value>
  </data>
  <data name="UnInstallCommandExamples" xml:space="preserve">
    <value>    libman uninstall jquery
    libman uninstall jquery@3.3.1</value>
  </data>
  <data name="UninstallCommandLibraryIdArgumentDesc" xml:space="preserve">
    <value>要卸载的库</value>
  </data>
  <data name="UninstallCommandProviderOptionDesc" xml:space="preserve">
    <value>要卸载的库的提供程序</value>
  </data>
  <data name="UnInstallCommandProviderSpecificLogic" xml:space="preserve">
    <value>CDNJS 库的库 ID 格式为“&lt;库名称&gt;@&lt;库版本&gt;”
    如果库 ID 中没有指定版本，此命令将作用于库名称与给定库 ID 匹配的任何库</value>
  </data>
  <data name="UnInstallCommandRemarks" xml:space="preserve">
    <value>若当前文件夹中不存在 libman.json 则出错
    若指定的库不存在则出错
    若有多个具有相同 libraryId 的库，则提示你进行选择。</value>
  </data>
  <data name="VerbosityOptionDesc" xml:space="preserve">
    <value>设置输出的详细程度(例如“正常”、“详细”、“安静”)</value>
  </data>
  <data name="ProjectPathOptionDesc" xml:space="preserve">
    <value>项目的路径(默认使用当前目录)</value>
  </data>
  <data name="DirectoryNotFoundMessage" xml:space="preserve">
    <value>找不到目录 {0}</value>
  </data>
  <data name="FailedToRestoreLibraryMessage" xml:space="preserve">
    <value>未能还原 "{0}"</value>
  </data>
  <data name="FileDeleted" xml:space="preserve">
    <value>已删除 {0}</value>
  </data>
  <data name="FileDeleteFail" xml:space="preserve">
    <value>未能删除 {0}</value>
  </data>
  <data name="FileWrittenToDisk" xml:space="preserve">
    <value>{0} 写入磁盘</value>
  </data>
  <data name="InitFailedLibmanJsonFileExists" xml:space="preserve">
    <value>初始化失败: "libman.json" 已存在</value>
  </data>
  <data name="CleanFailed" xml:space="preserve">
    <value>无法清理某些文件。</value>
  </data>
  <data name="LibmanJsonNotFound" xml:space="preserve">
    <value>未找到 libman.json:{0}</value>
  </data>
  <data name="DestinationRequiredWhenNoDefaultIsPresent" xml:space="preserve">
    <value>未设置默认目标。请使用 "--destination" 提供目标</value>
  </data>
  <data name="LibraryIdRequiredForInstall" xml:space="preserve">
    <value>需要 LibraryId 才能安装</value>
  </data>
  <data name="LibraryIdRequiredForUnInstall" xml:space="preserve">
    <value>需要 LibraryId 才能卸载</value>
  </data>
  <data name="MoreThanOneLibraryFoundToUninstall" xml:space="preserve">
    <value>发现多个 ID 为“{0}”的库</value>
  </data>
  <data name="ProviderRequiredWhenNoDefaultIsPresent" xml:space="preserve">
    <value>未设置默认提供程序。请用 "--provider" 提供提供程序</value>
  </data>
  <data name="UseProviderToDisambiguateMessage" xml:space="preserve">
    <value>使用 --provider 消除项目中来自不同提供程序的同名库的歧义</value>
  </data>
  <data name="MoreThanOneLibraryFoundToUninstallForProvider" xml:space="preserve">
    <value>为提供程序 "{1}" 找到 id 为 "{0}" 的多个库。请从 libman.json 文件中手动删除</value>
  </data>
  <data name="NoLibraryToUninstall" xml:space="preserve">
    <value>未安装库 "{0}"。没有可卸载的内容</value>
  </data>
  <data name="CacheCleanCommandDesc" xml:space="preserve">
    <value>从本地计算机的 LibMan 缓存中删除所有文件。</value>
  </data>
  <data name="CacheListCommandDesc" xml:space="preserve">
    <value>显示存储在本地计算机的 LibMan 缓存中的所有库的列表。</value>
  </data>
  <data name="CacheCleanProviderArgumentDesc" xml:space="preserve">
    <value>要为其清除缓存文件的提供程序。</value>
  </data>
  <data name="UpdateCommandDesc" xml:space="preserve">
    <value>更新指定的库</value>
  </data>
  <data name="UpdateCommandExamples" xml:space="preserve">
    <value>    libman update jquery
    libman update jquery --to 3.3.1
    libman update jquery -pre
</value>
  </data>
  <data name="UpdateCommandRemarks" xml:space="preserve">
    <value>若当前文件夹中不存在 libman.json 则出错
    若指定的库不存在则出错
    若有多个具有相同 libraryId 的库，则提示你进行选择。</value>
  </data>
  <data name="UpdateCommandLibraryArgumentDesc" xml:space="preserve">
    <value>要更新的库的名称 (不带版本)。</value>
  </data>
  <data name="UpdateCommandPreReleaseOptionDesc" xml:space="preserve">
    <value>如果指定, 将下载最新的库预发行版本 (如果适用)</value>
  </data>
  <data name="UpdateCommandProviderOptionDesc" xml:space="preserve">
    <value>如果指定, 则仅更新来自指定提供程序的库</value>
  </data>
  <data name="CacheCleanedMessage" xml:space="preserve">
    <value>已清理缓存。</value>
  </data>
  <data name="CacheCleanFailed" xml:space="preserve">
    <value>无法清除缓存: {0}</value>
  </data>
  <data name="CacheContentMessage" xml:space="preserve">
    <value>缓存内容:</value>
  </data>
  <data name="CacheEmptyMessage" xml:space="preserve">
    <value>(空)</value>
  </data>
  <data name="CacheForProviderCleanedMessage" xml:space="preserve">
    <value>已清除 {0} 缓存。</value>
  </data>
  <data name="CacheListFilesOptionDesc" xml:space="preserve">
    <value>列出为每个库缓存的文件</value>
  </data>
  <data name="MoreThanOneLibraryFoundToUpdate" xml:space="preserve">
    <value>发现多个名为 "{0}" 的库</value>
  </data>
  <data name="NoLibrariesToUpdate" xml:space="preserve">
    <value>没有要更新的库。请使用安装命令安装库</value>
  </data>
  <data name="NoLibraryFoundToUpdate" xml:space="preserve">
    <value>找不到名为 "{0}" 库以进行更新。
请指定不含版本信息的库名以进行更新。</value>
  </data>
  <data name="InstallLibraryFailed" xml:space="preserve">
    <value>安装库 "{0}" 失败</value>
  </data>
  <data name="CacheListLibrariesOptionDesc" xml:space="preserve">
    <value>列出为每个提供程序缓存的库。</value>
  </data>
  <data name="ProviderNotInstalled" xml:space="preserve">
    <value>未安装提供程序 "{0}"</value>
  </data>
  <data name="SuggestedIdsMessage" xml:space="preserve">
    <value>类似的库:</value>
  </data>
  <data name="FixManifestFile" xml:space="preserve">
    <value>请修复 libman.json 文件, 然后重试</value>
  </data>
  <data name="ChooseAnOption" xml:space="preserve">
    <value>选择一个选项:</value>
  </data>
  <data name="LatestVersionAlreadyInstalled" xml:space="preserve">
    <value>库 "{0}" 已是最新版本</value>
  </data>
  <data name="InvalidToVersion" xml:space="preserve">
    <value>"{0}" 不是 --to-version 的有效值</value>
  </data>
  <data name="UpdateCommandToVersionOptionDesc" xml:space="preserve">
    <value>要将库更新到的版本 (需要提供程序的完整 libraryid)</value>
  </data>
  <data name="InstalledLibrary" xml:space="preserve">
    <value>已将库 "{0}" 安装到 "{1}"</value>
  </data>
  <data name="UninstalledLibrary" xml:space="preserve">
    <value>已卸载库 "{0}"</value>
  </data>
  <data name="InvalidFilesForLibrary" xml:space="preserve">
    <value>库 "{0}" 不包含以下文件: {1}</value>
  </data>
  <data name="LibraryCannotBeInstalledDueToConflictingLibraries" xml:space="preserve">
    <value>无法安装库 "{0}"。"{1}" 已安装在 "{2}" 上。
请指定其他目标。</value>
  </data>
  <data name="LibraryIdRequiredForUpdate" xml:space="preserve">
    <value>需要 LibraryId 才能更新</value>
  </data>
  <data name="SpecifyDifferentDestination" xml:space="preserve">
    <value>请指定其他目标。</value>
  </data>
  <data name="UninstallFailed" xml:space="preserve">
    <value>未能卸载 "{0}"</value>
  </data>
  <data name="UpdateLibraryFailed" xml:space="preserve">
    <value>未能将 "{0}" 更新为 "{1}"</value>
  </data>
  <data name="UpdateLibraryToLatestFailed" xml:space="preserve">
    <value>未能将 "{0}" 更新到最新版本</value>
  </data>
  <data name="LibraryUpdated" xml:space="preserve">
    <value>已将 "{0}" 更新为 "{1}"</value>
  </data>
  <data name="UnableToFindLatestVersionForLibrary" xml:space="preserve">
    <value>无法确定 "{0}" 的最新版本</value>
  </data>
  <data name="InitFailedUnknownProvider" xml:space="preserve">
    <value>无法初始化 libman. json。[{0}]: {1}</value>
  </data>
  <data name="SpecifyDisabmiguatedLibrary" xml:space="preserve">
    <value>请指定完整的库 ID，并使用 “--provider” 选项指定提供程序。</value>
  </data>
  <data name="SpecifyFieldUsingOption" xml:space="preserve">
    <value>请使用 “--{1}” 选项指定“{0}”。</value>
  </data>
  <data name="ConfigCommand_Error_ConflictingParameters" xml:space="preserve">
    <value>无法在同一操作中读取和写入设置</value>
  </data>
  <data name="ConfigCommand_OptionDescription_Set" xml:space="preserve">
    <value>在配置存储区中设置键值对。 此选项应采用 "键=值" 格式</value>
  </data>
  <data name="ConfigCommand_OptionDescription_SetEncrypted" xml:space="preserve">
    <value>在配置存储区中设置具有加密值的键。 此选项应采用 "键=纯文本" 格式</value>
  </data>
  <data name="ConfigCommand_Remarks" xml:space="preserve">
    <value>    无法在同一操作中读取和保存设置。
    要删除某个设置，请将其设置为空字符串(--set key=)。
    不支持检索已加密设置的解密值。</value>
  </data>
  <data name="CacheLocationMessage" xml:space="preserve">
    <value>缓存根目录:</value>
  </data>
  <data name="UseDefault" xml:space="preserve">
    <value>使用 libman.json 文件的默认设置</value>
  </data>
</root>