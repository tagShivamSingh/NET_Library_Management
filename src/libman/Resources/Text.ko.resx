<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CacheCommandDesc" xml:space="preserve">
    <value>libman 캐시 내용 나열 또는 지우기</value>
  </data>
  <data name="CleanCommandDesc" xml:space="preserve">
    <value>libman.json에 정의된 모든 라이브러리 파일을 프로젝트에서 삭제합니다.</value>
  </data>
  <data name="CleanCommandRemarks" xml:space="preserve">
    <value>이 작업 후 비어 있게 되는 폴더를 삭제합니다.</value>
  </data>
  <data name="ConfigCommand_Description" xml:space="preserve">
    <value>구성 설정을 가져오거나 설정합니다.</value>
  </data>
  <data name="ConfigCommand_Examples" xml:space="preserve">
    <value>    libman config http_proxy
    libman config --set http_proxy=http://example
    libman config --setEncrypted http_proxy.password=passwordText</value>
  </data>
  <data name="ConfigCommand_ArgumentDescription" xml:space="preserve">
    <value>검색할 설정의 이름</value>
  </data>
  <data name="ConfigCommand_Error_KeyNotFound" xml:space="preserve">
    <value>{0} 키를 찾을 수 없습니다.</value>
  </data>
  <data name="DefaultDestinationOptionDesc" xml:space="preserve">
    <value>지정한 라이브러리에 대해 대상을 정의하지 않은 경우 라이브러리 파일을 설치해야 하는 경로로, 현재 디렉터리에 상대적입니다.</value>
  </data>
  <data name="DefaultProviderOptionDesc" xml:space="preserve">
    <value>지정된 라이브러리에 대해 공급자를 지정하지 않은 경우 사용할 공급자입니다. (예: “cdnjs”, “filesystem”)</value>
  </data>
  <data name="NonInteractiveConsoleMessage" xml:space="preserve">
    <value>이 콘솔에서 사용자 입력을 묻는 메시지를 표시할 수 없습니다.</value>
  </data>
  <data name="DestinationOptionDesc" xml:space="preserve">
    <value>라이브러리를 설치할 위치(지정하지 않으면 기본 대상 위치가 사용됨)</value>
  </data>
  <data name="ExamplesHeader" xml:space="preserve">
    <value>예:</value>
  </data>
  <data name="FilesOptionDesc" xml:space="preserve">
    <value>지정한 라이브러리에서 설치할 파일(지정하지 않으면 라이브러리의 모든 파일이 설치됨)</value>
  </data>
  <data name="InitCommandDesc" xml:space="preserve">
    <value>새 libman.json을 만듭니다.</value>
  </data>
  <data name="InstallCommandDesc" xml:space="preserve">
    <value>LibMan.json 파일에 라이브러리 정의를 추가하고 라이브러리를 지정한 위치로 다운로드하세요.</value>
  </data>
  <data name="InstallCommandExamples" xml:space="preserve">
    <value>libman install jquery@3.2.1
    libman install jquery --provider cdnjs --destination wwwroot\scripts\jquery --files jquery.min.js
    libman install myCalendar --provider filesystem --files calendar.js --files calendar.css</value>
  </data>
  <data name="InstallCommandLibraryIdArgumentDesc" xml:space="preserve">
    <value>설치할 라이브러리</value>
  </data>
  <data name="InstallCommandProviderSpecificLogic" xml:space="preserve">
    <value>    CDNJS 라이브러리의 라이브러리 ID 형식은 "&lt;라이브러리 이름&gt;@&lt;라이브러리 버전&gt;"입니다.
    CDNJS 라이브러리의 경우 라이브러리 ID에 버전을 지정하지 않으면 사용 가능한 최고 버전이 사용됩니다.</value>
  </data>
  <data name="InstallCommandRemarks" xml:space="preserve">
    <value>    없으면 libman.json을 초기화합니다.
    기본 공급자가 없으면 --provider 옵션이 필요합니다.
    기본 대상이 없으면 --destination 옵션이 필요합니다.
    파일을 지정하지 않은 경우 전체 라이브러리가 포함됩니다.</value>
  </data>
  <data name="InvalidArgumentsMessage" xml:space="preserve">
    <value>명령의 인수가 잘못되었습니다. {0}</value>
  </data>
  <data name="LibmanCommandDesc" xml:space="preserve">
    <value>라이브러리 관리자</value>
  </data>
  <data name="ProviderOptionDesc" xml:space="preserve">
    <value>사용할 공급자(지정하지 않으면 기본 공급자가 사용됨)</value>
  </data>
  <data name="ProviderSpecificLogicHeader" xml:space="preserve">
    <value>공급자별 논리:</value>
  </data>
  <data name="RemarksHeader" xml:space="preserve">
    <value>설명:</value>
  </data>
  <data name="RestoreCommandDesc" xml:space="preserve">
    <value>공급자에서 모든 파일을 다운로드하여 지정된 대상에 저장합니다.</value>
  </data>
  <data name="RestoreCommandRemarks" xml:space="preserve">
    <value>현재 폴더에 libman.json이 없으면 오류가 발생합니다.
    라이브러리에서 공급자를 지정하면 이 공급자로 defaultProvider가 재정의됩니다.
    라이브러리에서 대상을 지정하면 이 대상으로 defaultDestination이 재정의됩니다.</value>
  </data>
  <data name="UnInstallCommandDesc" xml:space="preserve">
    <value>지정한 라이브러리의 모든 파일을 지정된 대상에서 삭제한 다음 지정된 라이브러리 정의를 libman.json에서 제거합니다.</value>
  </data>
  <data name="UnInstallCommandExamples" xml:space="preserve">
    <value>    libman uninstall jquery
    libman uninstall jquery@3.3.1</value>
  </data>
  <data name="UninstallCommandLibraryIdArgumentDesc" xml:space="preserve">
    <value>제거할 라이브러리</value>
  </data>
  <data name="UninstallCommandProviderOptionDesc" xml:space="preserve">
    <value>제거할 라이브러리의 공급자</value>
  </data>
  <data name="UnInstallCommandProviderSpecificLogic" xml:space="preserve">
    <value>    CDNJS 라이브러리의 라이브러리 ID 형식은 "&lt;라이브러리 이름&gt;@&lt;라이브러리 버전&gt;"입니다.
    라이브러리 ID에 버전을 지정하지 않으면 지정된 라이브러리 ID와 일치하는 라이브러리 이름이 있는 모든 라이브러리에 이 명령이 실행됩니다.</value>
  </data>
  <data name="UnInstallCommandRemarks" xml:space="preserve">
    <value>현재 폴더에 libman.json이 없으면 오류가 발생합니다.
    지정한 라이브러리가 없으면 오류가 발생합니다.
    같은 libraryId의 라이브러리가 둘 이상 있으면 선택하라는 메시지가 표시됩니다.</value>
  </data>
  <data name="VerbosityOptionDesc" xml:space="preserve">
    <value>출력의 세부 정보 표시 수준 설정(예: "normal", "detailed", "quiet")</value>
  </data>
  <data name="ProjectPathOptionDesc" xml:space="preserve">
    <value>프로젝트의 경로(기본적으로 현재 디렉터리가 사용됨)</value>
  </data>
  <data name="DirectoryNotFoundMessage" xml:space="preserve">
    <value>{0} 디렉터리를 찾을 수 없습니다.</value>
  </data>
  <data name="FailedToRestoreLibraryMessage" xml:space="preserve">
    <value>"{0}"을(를) 복원하지 못했습니다.</value>
  </data>
  <data name="FileDeleted" xml:space="preserve">
    <value>{0}이(가) 삭제됨</value>
  </data>
  <data name="FileDeleteFail" xml:space="preserve">
    <value>{0}을(를) 삭제하지 못했습니다.</value>
  </data>
  <data name="FileWrittenToDisk" xml:space="preserve">
    <value>{0}이(가) 디스크에 기록되었습니다.</value>
  </data>
  <data name="InitFailedLibmanJsonFileExists" xml:space="preserve">
    <value>초기화하지 못함: 'libman.json'이 이미 있습니다.</value>
  </data>
  <data name="CleanFailed" xml:space="preserve">
    <value>일부 파일을 정리하지 못했습니다.</value>
  </data>
  <data name="LibmanJsonNotFound" xml:space="preserve">
    <value>libman.json이 없습니다. {0}</value>
  </data>
  <data name="DestinationRequiredWhenNoDefaultIsPresent" xml:space="preserve">
    <value>기본 대상이 설정되지 않았습니다. '--destination'을 사용하여 설정하세요.</value>
  </data>
  <data name="LibraryIdRequiredForInstall" xml:space="preserve">
    <value>설치하려면 LibraryId가 필요합니다.</value>
  </data>
  <data name="LibraryIdRequiredForUnInstall" xml:space="preserve">
    <value>제거하려면 LibraryId가 필요합니다.</value>
  </data>
  <data name="MoreThanOneLibraryFoundToUninstall" xml:space="preserve">
    <value>ID가 "{0}"인 라이브러리를 둘 이상 찾았습니다.</value>
  </data>
  <data name="ProviderRequiredWhenNoDefaultIsPresent" xml:space="preserve">
    <value>기본 공급자가 설정되지 않았습니다. '--provider'를 사용하여 공급자를 지정하세요.</value>
  </data>
  <data name="UseProviderToDisambiguateMessage" xml:space="preserve">
    <value>--provider를 사용하여 프로젝트에서 다른 공급자에 있는 같은 이름의 라이브러리를 구분하세요.</value>
  </data>
  <data name="MoreThanOneLibraryFoundToUninstallForProvider" xml:space="preserve">
    <value>공급자 "{1}"에 대해 ID가 "{0}"인 라이브러리를 둘 이상 찾았습니다. libman.json 파일에서 수동으로 제거하세요.</value>
  </data>
  <data name="NoLibraryToUninstall" xml:space="preserve">
    <value>라이브러리 "{0}"이(가) 설치되어 있지 않습니다. 제거할 항목이 없습니다.</value>
  </data>
  <data name="CacheCleanCommandDesc" xml:space="preserve">
    <value>로컬 컴퓨터의 LibMan 캐시에서 모든 파일을 삭제하세요.</value>
  </data>
  <data name="CacheListCommandDesc" xml:space="preserve">
    <value>로컬 컴퓨터의 LibMan 캐시에 저장된 모든 라이브러리의 목록을 표시합니다.</value>
  </data>
  <data name="CacheCleanProviderArgumentDesc" xml:space="preserve">
    <value>캐시 파일을 정리할 공급자입니다.</value>
  </data>
  <data name="UpdateCommandDesc" xml:space="preserve">
    <value>지정한 라이브러리를 업데이트합니다.</value>
  </data>
  <data name="UpdateCommandExamples" xml:space="preserve">
    <value>    libman update jquery
    libman update jquery --to 3.3.1
    libman update jquery -pre
</value>
  </data>
  <data name="UpdateCommandRemarks" xml:space="preserve">
    <value>현재 폴더에 libman.json이 없으면 오류가 발생합니다.
    지정한 라이브러리가 없으면 오류가 발생합니다.
    같은 libraryId의 라이브러리가 둘 이상 있으면 선택하라는 메시지가 표시됩니다.</value>
  </data>
  <data name="UpdateCommandLibraryArgumentDesc" xml:space="preserve">
    <value>업데이트할 라이브러리 이름입니다(버전 제외).</value>
  </data>
  <data name="UpdateCommandPreReleaseOptionDesc" xml:space="preserve">
    <value>지정하면 라이브러리의 최신 시험판 버전이 다운로드됩니다(해당하는 경우).</value>
  </data>
  <data name="UpdateCommandProviderOptionDesc" xml:space="preserve">
    <value>지정하는 경우 지정한 공급자의 라이브러리만 업데이트됩니다.</value>
  </data>
  <data name="CacheCleanedMessage" xml:space="preserve">
    <value>캐시가 정리되었습니다.</value>
  </data>
  <data name="CacheCleanFailed" xml:space="preserve">
    <value>캐시를 정리하지 못했습니다. {0}</value>
  </data>
  <data name="CacheContentMessage" xml:space="preserve">
    <value>캐시 콘텐츠:</value>
  </data>
  <data name="CacheEmptyMessage" xml:space="preserve">
    <value>(비어 있음)</value>
  </data>
  <data name="CacheForProviderCleanedMessage" xml:space="preserve">
    <value>{0} 캐시가 정리되었습니다.</value>
  </data>
  <data name="CacheListFilesOptionDesc" xml:space="preserve">
    <value>각 라이브러리에 대해 캐시된 파일 나열</value>
  </data>
  <data name="MoreThanOneLibraryFoundToUpdate" xml:space="preserve">
    <value>이름이 "{0}"인 라이브러리를 둘 이상 찾았습니다.</value>
  </data>
  <data name="NoLibrariesToUpdate" xml:space="preserve">
    <value>업데이트할 라이브러리가 없습니다. 설치 명령을 사용하여 라이브러리를 설치하세요.</value>
  </data>
  <data name="NoLibraryFoundToUpdate" xml:space="preserve">
    <value>업데이트할 이름이 "{0}"인 라이브러리가 없습니다.
업데이트할 라이브러리 이름을 버전 정보 없이 지정하세요.</value>
  </data>
  <data name="InstallLibraryFailed" xml:space="preserve">
    <value>"{0}" 라이브러리를 설치하지 못했습니다.</value>
  </data>
  <data name="CacheListLibrariesOptionDesc" xml:space="preserve">
    <value>각 공급자에 대해 캐시된 라이브러리를 나열합니다.</value>
  </data>
  <data name="ProviderNotInstalled" xml:space="preserve">
    <value>"{0}" 공급자가 설치되어 있지 않습니다.</value>
  </data>
  <data name="SuggestedIdsMessage" xml:space="preserve">
    <value>유사한 라이브러리: </value>
  </data>
  <data name="FixManifestFile" xml:space="preserve">
    <value>libman.json 파일을 수정하고 다시 시도하세요.</value>
  </data>
  <data name="ChooseAnOption" xml:space="preserve">
    <value>옵션 선택:</value>
  </data>
  <data name="LatestVersionAlreadyInstalled" xml:space="preserve">
    <value>"{0}" 라이브러리는 이미 최신 상태입니다.</value>
  </data>
  <data name="InvalidToVersion" xml:space="preserve">
    <value>"{0}"은(는) --to-version에 유효한 값이 아닙니다.</value>
  </data>
  <data name="UpdateCommandToVersionOptionDesc" xml:space="preserve">
    <value>라이브러리를 업데이트할 버전(공급자의 전체 libraryid 필요)</value>
  </data>
  <data name="InstalledLibrary" xml:space="preserve">
    <value>"{0}" 라이브러리를 "{1}"에 설치했습니다.</value>
  </data>
  <data name="UninstalledLibrary" xml:space="preserve">
    <value>"{0}" 라이브러리를 제거함</value>
  </data>
  <data name="InvalidFilesForLibrary" xml:space="preserve">
    <value>"{0}" 라이브러리에 다음 파일이 포함되어 있지 않습니다. {1}</value>
  </data>
  <data name="LibraryCannotBeInstalledDueToConflictingLibraries" xml:space="preserve">
    <value>"{0}" 라이브러리를 설치할 수 없습니다. "{1}"이(가) "{2}"에 이미 설치되어 있습니다.
다른 대상을 지정하세요.</value>
  </data>
  <data name="LibraryIdRequiredForUpdate" xml:space="preserve">
    <value>업데이트하려면 LibraryId가 필요합니다.</value>
  </data>
  <data name="SpecifyDifferentDestination" xml:space="preserve">
    <value>다른 대상을 지정하세요.</value>
  </data>
  <data name="UninstallFailed" xml:space="preserve">
    <value>"{0}"을(를) 제거하지 못했습니다.</value>
  </data>
  <data name="UpdateLibraryFailed" xml:space="preserve">
    <value>"{0}"을(를) "{1}"(으)로 업데이트하지 못했습니다.</value>
  </data>
  <data name="UpdateLibraryToLatestFailed" xml:space="preserve">
    <value>"{0}"을(를) 최신 버전으로 업데이트하지 못했습니다.</value>
  </data>
  <data name="LibraryUpdated" xml:space="preserve">
    <value>"{0}"을(를) "{1}"(으)로 업데이트했습니다.</value>
  </data>
  <data name="UnableToFindLatestVersionForLibrary" xml:space="preserve">
    <value>"{0}"에 대한 최신 버전을 확인할 수 없습니다.</value>
  </data>
  <data name="InitFailedUnknownProvider" xml:space="preserve">
    <value>libman.json을 초기화하지 못했습니다. [{0}]: {1}</value>
  </data>
  <data name="SpecifyDisabmiguatedLibrary" xml:space="preserve">
    <value>전체 라이브러리 ID를 지정하고 '--provider' 옵션을 사용하여 공급자도 지정하세요.</value>
  </data>
  <data name="SpecifyFieldUsingOption" xml:space="preserve">
    <value>'--{1}' 옵션을 사용하여 '{0}'을(를) 지정하세요.</value>
  </data>
  <data name="ConfigCommand_Error_ConflictingParameters" xml:space="preserve">
    <value>같은 작업에서 설정을 읽고 쓸 수 없습니다.</value>
  </data>
  <data name="ConfigCommand_OptionDescription_Set" xml:space="preserve">
    <value>구성 저장소에 키-값 쌍을 설정합니다. 이 옵션은 key=value 형식이어야 합니다.</value>
  </data>
  <data name="ConfigCommand_OptionDescription_SetEncrypted" xml:space="preserve">
    <value>구성 저장소에 암호화된 값으로 키를 설정합니다. 이 옵션은 key=plaintext 형식이어야 합니다.</value>
  </data>
  <data name="ConfigCommand_Remarks" xml:space="preserve">
    <value>    같은 작업에서 설정을 읽고 저장할 수 없습니다.
    설정을 제거하려면 빈 문자열(--set key=)로 설정합니다.
    암호화된 설정의 암호 해독된 값 검색은 지원되지 않습니다.</value>
  </data>
  <data name="CacheLocationMessage" xml:space="preserve">
    <value>캐시 루트 디렉터리:</value>
  </data>
  <data name="UseDefault" xml:space="preserve">
    <value>libman.json 파일에 대한 기본 설정 사용</value>
  </data>
</root>