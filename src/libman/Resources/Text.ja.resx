<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CacheCommandDesc" xml:space="preserve">
    <value>libman キャッシュ コンテンツをリストまたはクリーンします</value>
  </data>
  <data name="CleanCommandDesc" xml:space="preserve">
    <value>libman.json で定義されているすべてのライブラリ ファイルをプロジェクトから削除します</value>
  </data>
  <data name="CleanCommandRemarks" xml:space="preserve">
    <value>この操作の後、空になったフォルダーがあればすべて削除します。</value>
  </data>
  <data name="ConfigCommand_Description" xml:space="preserve">
    <value>構成設定を取得または設定します</value>
  </data>
  <data name="ConfigCommand_Examples" xml:space="preserve">
    <value>    libman config http_proxy
    libman config --set http_proxy=http://example
    libman config --setEncrypted http_proxy.password=passwordText</value>
  </data>
  <data name="ConfigCommand_ArgumentDescription" xml:space="preserve">
    <value>取得する設定の名前</value>
  </data>
  <data name="ConfigCommand_Error_KeyNotFound" xml:space="preserve">
    <value>キー {0} が見つかりません。</value>
  </data>
  <data name="DefaultDestinationOptionDesc" xml:space="preserve">
    <value>指定されたライブラリに宛先が定義されていない場合、ライブラリ ファイルがインストールされる現在のディレクトリに対する相対パス。</value>
  </data>
  <data name="DefaultProviderOptionDesc" xml:space="preserve">
    <value>指定されたライブラリでプロバイダーが定義されていない場合に使用するプロバイダー (“cdnjs”、“filesystem” など)</value>
  </data>
  <data name="NonInteractiveConsoleMessage" xml:space="preserve">
    <value>このコンソールでユーザーの入力を要求することはできません。</value>
  </data>
  <data name="DestinationOptionDesc" xml:space="preserve">
    <value>ライブラリをインストールする場所 (指定しない場合、既定のインストール先の場所が使用されます)</value>
  </data>
  <data name="ExamplesHeader" xml:space="preserve">
    <value>例:</value>
  </data>
  <data name="FilesOptionDesc" xml:space="preserve">
    <value>指定されたライブラリのインストール対象ファイル (指定しない場合、ライブラリのすべてのファイルがインストールされます)</value>
  </data>
  <data name="InitCommandDesc" xml:space="preserve">
    <value>新しい libman.json を作成します</value>
  </data>
  <data name="InstallCommandDesc" xml:space="preserve">
    <value>ライブラリ定義を LibMan.json ファイルに追加し、指定した場所にライブラリをダウンロードします</value>
  </data>
  <data name="InstallCommandExamples" xml:space="preserve">
    <value>libman install jquery@3.2.1
    libman install jquery --provider cdnjs --destination wwwroot\scripts\jquery --files jquery.min.js
    libman install myCalendar --provider filesystem --files calendar.js --files calendar.css</value>
  </data>
  <data name="InstallCommandLibraryIdArgumentDesc" xml:space="preserve">
    <value>インストールするライブラリ</value>
  </data>
  <data name="InstallCommandProviderSpecificLogic" xml:space="preserve">
    <value>    CDNJS ライブラリのライブラリ ID の形式は "&lt;ライブラリ名&gt;@&lt;ライブラリバージョン&gt;" です
    CDNJS ライブラリで、ライブラリ ID にバージョンが指定されていない場合、使用可能な最新のバージョンが使用されます。</value>
  </data>
  <data name="InstallCommandRemarks" xml:space="preserve">
    <value>libman.json が存在しない場合は、初期化されます
    既定のプロバイダーが存在しない場合は、--provider オプションが必要です
    既定の宛先が存在はない場合は、--destination オプションが必要です
    ファイルを指定しない場合は、ライブラリ全体がインクルードされます</value>
  </data>
  <data name="InvalidArgumentsMessage" xml:space="preserve">
    <value>コマンドの引数が無効です: {0}</value>
  </data>
  <data name="LibmanCommandDesc" xml:space="preserve">
    <value>ライブラリ マネージャー</value>
  </data>
  <data name="ProviderOptionDesc" xml:space="preserve">
    <value>使用するプロバイダー (指定しない場合、既定のプロバイダーが使用されます)</value>
  </data>
  <data name="ProviderSpecificLogicHeader" xml:space="preserve">
    <value>プロバイダー固有のロジック:</value>
  </data>
  <data name="RemarksHeader" xml:space="preserve">
    <value>注釈:</value>
  </data>
  <data name="RestoreCommandDesc" xml:space="preserve">
    <value>プロバイダーからすべてのファイルをダウンロードし、指定した宛先に保存します</value>
  </data>
  <data name="RestoreCommandRemarks" xml:space="preserve">
    <value>現在のフォルダーに libman.json がない場合は、エラーになります。
    ライブラリでプロバイダーを指定している場合は、defaultProvider がオーバーライドされます。
    ライブラリで宛先を指定している場合は、defaultDestination がオーバーライドされます。</value>
  </data>
  <data name="UnInstallCommandDesc" xml:space="preserve">
    <value>指定したターゲットから指定したライブラリのすべてのファイルを削除し、libman.json から指定したライブラリの定義を削除します</value>
  </data>
  <data name="UnInstallCommandExamples" xml:space="preserve">
    <value>    libman uninstall jquery
    libman uninstall jquery@3.3.1</value>
  </data>
  <data name="UninstallCommandLibraryIdArgumentDesc" xml:space="preserve">
    <value>アンインストールするライブラリ</value>
  </data>
  <data name="UninstallCommandProviderOptionDesc" xml:space="preserve">
    <value>アンインストールするライブラリのプロバイダー</value>
  </data>
  <data name="UnInstallCommandProviderSpecificLogic" xml:space="preserve">
    <value>    CDNJS ライブラリのライブラリ ID の形式は "&lt;ライブラリ名&gt;@&lt;ライブラリバージョン&gt;" です
    ライブラリ ID にバージョンが指定されていない場合、このコマンドは、指定されたライブラリID に一致するライブラリ名を持つ任意のライブラリで動作します</value>
  </data>
  <data name="UnInstallCommandRemarks" xml:space="preserve">
    <value>現在のフォルダーに libman.json がない場合は、エラーになります
    指定したライブラリが存在しな場合は、エラーになります
    同じ libraryId のライブラリが複数ある場合は、選択するようにとのプロンプトが出ます。</value>
  </data>
  <data name="VerbosityOptionDesc" xml:space="preserve">
    <value>出力の詳細度を設定します ("normal"、"detailed"、"quiet" など)</value>
  </data>
  <data name="ProjectPathOptionDesc" xml:space="preserve">
    <value>プロジェクトへのパス (既定では現在のディレクトリが使用されます)</value>
  </data>
  <data name="DirectoryNotFoundMessage" xml:space="preserve">
    <value>ディレクトリ {0} が見つかりません</value>
  </data>
  <data name="FailedToRestoreLibraryMessage" xml:space="preserve">
    <value>"{0}" を復元できませんでした</value>
  </data>
  <data name="FileDeleted" xml:space="preserve">
    <value>{0} は削除されました</value>
  </data>
  <data name="FileDeleteFail" xml:space="preserve">
    <value>{0} を削除できませんでした。</value>
  </data>
  <data name="FileWrittenToDisk" xml:space="preserve">
    <value>{0} はディスクに書き込まれました</value>
  </data>
  <data name="InitFailedLibmanJsonFileExists" xml:space="preserve">
    <value>初期化に失敗しました: 'libman.json' は既に存在します</value>
  </data>
  <data name="CleanFailed" xml:space="preserve">
    <value>いくつかのファイルをクリーンアップできませんでした。</value>
  </data>
  <data name="LibmanJsonNotFound" xml:space="preserve">
    <value>libman.json が見つかりませんでした: {0}</value>
  </data>
  <data name="DestinationRequiredWhenNoDefaultIsPresent" xml:space="preserve">
    <value>既定の宛先が設定されていません。 '--destination' を使用して宛先を指定してください</value>
  </data>
  <data name="LibraryIdRequiredForInstall" xml:space="preserve">
    <value>インストールするにはライブラリ ID が必要です</value>
  </data>
  <data name="LibraryIdRequiredForUnInstall" xml:space="preserve">
    <value>アンインストールするには LibraryId が必要です</value>
  </data>
  <data name="MoreThanOneLibraryFoundToUninstall" xml:space="preserve">
    <value>ID が "{0}" のライブラリが複数あります。</value>
  </data>
  <data name="ProviderRequiredWhenNoDefaultIsPresent" xml:space="preserve">
    <value>既定のプロバイダーが設定されていません。'--provider' を使用してプロバイダーを指定してください</value>
  </data>
  <data name="UseProviderToDisambiguateMessage" xml:space="preserve">
    <value>同じ名前のライブラリとプロジェクト内の異なるプロバイダーを区別するには --provider を使用します</value>
  </data>
  <data name="MoreThanOneLibraryFoundToUninstallForProvider" xml:space="preserve">
    <value>プロバイダー "{1}" には ID が "{0}" のライブラリが複数あります。libman.json ファイルから手動で削除してください</value>
  </data>
  <data name="NoLibraryToUninstall" xml:space="preserve">
    <value>ライブラリ "{0}" はインストールされていません。アンインストールするものがありません</value>
  </data>
  <data name="CacheCleanCommandDesc" xml:space="preserve">
    <value>ローカル マシンの LibMan キャッシュからすべてのファイルを削除します。</value>
  </data>
  <data name="CacheListCommandDesc" xml:space="preserve">
    <value>ローカル マシンの LibMan キャッシュに格納されているすべてのライブラリの一覧を表示します。</value>
  </data>
  <data name="CacheCleanProviderArgumentDesc" xml:space="preserve">
    <value>キャッシュ ファイルを消去する必要のあるプロバイダー。</value>
  </data>
  <data name="UpdateCommandDesc" xml:space="preserve">
    <value>指定したライブラリを更新します</value>
  </data>
  <data name="UpdateCommandExamples" xml:space="preserve">
    <value>    libman update jquery
    libman update jquery --to 3.3.1
    libman update jquery -pre
</value>
  </data>
  <data name="UpdateCommandRemarks" xml:space="preserve">
    <value>現在のフォルダーに libman.json がない場合は、エラーになります
    指定したライブラリが存在しな場合は、エラーになります
    同じ libraryId のライブラリが複数ある場合は、選択するようにとのプロンプトが出ます。</value>
  </data>
  <data name="UpdateCommandLibraryArgumentDesc" xml:space="preserve">
    <value>更新するライブラリの名前 (バージョンを含めない)。</value>
  </data>
  <data name="UpdateCommandPreReleaseOptionDesc" xml:space="preserve">
    <value>指定した場合、ライブラリの最新のプレリリース バージョンがダウンロードされます (存在する場合)</value>
  </data>
  <data name="UpdateCommandProviderOptionDesc" xml:space="preserve">
    <value>指定すると、指定されたプロバイダーのライブラリのみが更新されます</value>
  </data>
  <data name="CacheCleanedMessage" xml:space="preserve">
    <value>キャッシュがクリーンアップされました。</value>
  </data>
  <data name="CacheCleanFailed" xml:space="preserve">
    <value>キャッシュを消去できませんでした: {0}</value>
  </data>
  <data name="CacheContentMessage" xml:space="preserve">
    <value>キャッシュの内容:</value>
  </data>
  <data name="CacheEmptyMessage" xml:space="preserve">
    <value>(空)</value>
  </data>
  <data name="CacheForProviderCleanedMessage" xml:space="preserve">
    <value>{0} キャッシュがクリーンアップされました。</value>
  </data>
  <data name="CacheListFilesOptionDesc" xml:space="preserve">
    <value>各ライブラリのキャッシュされたファイルを一覧表示します</value>
  </data>
  <data name="MoreThanOneLibraryFoundToUpdate" xml:space="preserve">
    <value>名前が "{0}" のライブラリが複数見つかりました</value>
  </data>
  <data name="NoLibrariesToUpdate" xml:space="preserve">
    <value>更新するライブラリがありません。インストール コマンドを使ってライブラリをインストールしてください。</value>
  </data>
  <data name="NoLibraryFoundToUpdate" xml:space="preserve">
    <value>名前が "{0}" の更新するライブラリが見つかりません。
更新するライブラリ名を、バージョン情報なしで指定してください。</value>
  </data>
  <data name="InstallLibraryFailed" xml:space="preserve">
    <value>ライブラリ "{0}" をインストールできませんでした</value>
  </data>
  <data name="CacheListLibrariesOptionDesc" xml:space="preserve">
    <value>各プロバイダーにキャッシュされたライブラリをリストします。</value>
  </data>
  <data name="ProviderNotInstalled" xml:space="preserve">
    <value>プロバイダー "{0}" はインストールされていません</value>
  </data>
  <data name="SuggestedIdsMessage" xml:space="preserve">
    <value>類似ライブラリ: </value>
  </data>
  <data name="FixManifestFile" xml:space="preserve">
    <value>libman.json ファイルを修正して、もう一度やり直してください</value>
  </data>
  <data name="ChooseAnOption" xml:space="preserve">
    <value>オプションを選択:</value>
  </data>
  <data name="LatestVersionAlreadyInstalled" xml:space="preserve">
    <value>ライブラリ "{0}" は既に最新の状態です</value>
  </data>
  <data name="InvalidToVersion" xml:space="preserve">
    <value>"{0}" は --to-version の有効な値ではありません</value>
  </data>
  <data name="UpdateCommandToVersionOptionDesc" xml:space="preserve">
    <value>ライブラリを更新するバージョン (プロバイダーの完全な libraryid が必要)</value>
  </data>
  <data name="InstalledLibrary" xml:space="preserve">
    <value>ライブラリ "{0}" が "{1}" にインストールされました</value>
  </data>
  <data name="UninstalledLibrary" xml:space="preserve">
    <value>ライブラリ "{0}" がアンインストールされました</value>
  </data>
  <data name="InvalidFilesForLibrary" xml:space="preserve">
    <value>ライブラリ "{0}" に次のファイルは含まれていません: {1}</value>
  </data>
  <data name="LibraryCannotBeInstalledDueToConflictingLibraries" xml:space="preserve">
    <value>ライブラリ "{0}" はインストールできません。"{1}" は既に "{2}" にインストールされています。
別のインストール先を指定してください。</value>
  </data>
  <data name="LibraryIdRequiredForUpdate" xml:space="preserve">
    <value>更新するには libraryId が必要です</value>
  </data>
  <data name="SpecifyDifferentDestination" xml:space="preserve">
    <value>別の宛先を指定してください。</value>
  </data>
  <data name="UninstallFailed" xml:space="preserve">
    <value>"{0}" をアンインストールできませんでした</value>
  </data>
  <data name="UpdateLibraryFailed" xml:space="preserve">
    <value>"{0}" を "{1}" に更新できませんでした</value>
  </data>
  <data name="UpdateLibraryToLatestFailed" xml:space="preserve">
    <value>"{0}" を最新バージョンに更新できませんでした</value>
  </data>
  <data name="LibraryUpdated" xml:space="preserve">
    <value>"{0}" が "{1}" に更新されました</value>
  </data>
  <data name="UnableToFindLatestVersionForLibrary" xml:space="preserve">
    <value>"{0}" の最新バージョンを特定できませんでした</value>
  </data>
  <data name="InitFailedUnknownProvider" xml:space="preserve">
    <value>Libman.json を初期化できませんでした。[{0}]: {1}</value>
  </data>
  <data name="SpecifyDisabmiguatedLibrary" xml:space="preserve">
    <value>完全なライブラリ ID と、'--provider' オプションを使用してプロバイダーを指定してください。</value>
  </data>
  <data name="SpecifyFieldUsingOption" xml:space="preserve">
    <value>'--{1}' オプションを使って '{0}' を指定してください。</value>
  </data>
  <data name="ConfigCommand_Error_ConflictingParameters" xml:space="preserve">
    <value>同じ操作で設定の読み取りと書き込みを行うことはできません</value>
  </data>
  <data name="ConfigCommand_OptionDescription_Set" xml:space="preserve">
    <value>キーと値のペアを構成ストアに設定します。オプションは、key=value の形式にする必要があります</value>
  </data>
  <data name="ConfigCommand_OptionDescription_SetEncrypted" xml:space="preserve">
    <value>暗号化された値を含むキーを構成ストアに設定します。オプションは、key=plaintext の形式にする必要があります</value>
  </data>
  <data name="ConfigCommand_Remarks" xml:space="preserve">
    <value>    設定を同じ操作で読み取り、保存することはできません。
    設定を削除するには、空の文字列 (--set key=) に設定します。
    暗号化された設定の暗号化解除された値の取得はサポートされていません。</value>
  </data>
  <data name="CacheLocationMessage" xml:space="preserve">
    <value>キャッシュ ルート ディレクトリ:</value>
  </data>
  <data name="UseDefault" xml:space="preserve">
    <value>libman.json ファイルの既定の設定を使用する</value>
  </data>
</root>